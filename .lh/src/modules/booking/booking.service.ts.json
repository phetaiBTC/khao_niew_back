{
    "sourceFile": "src/modules/booking/booking.service.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 11,
            "patches": [
                {
                    "date": 1756740733216,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1756740740250,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,286 @@\n+import { Inject, Injectable, NotFoundException } from '@nestjs/common';\r\n+import { CreateBookingDto } from './dto/create-booking.dto';\r\n+import { UpdateBookingDto } from './dto/update-booking.dto';\r\n+import { Booking } from './entities/booking.entity';\r\n+import { Payment } from '../payment/entities/payment.entity';\r\n+import { Concert } from '../concerts/entities/concert.entity';\r\n+import { Repository, DataSource } from 'typeorm';\r\n+import { InjectDataSource, InjectRepository } from '@nestjs/typeorm';\r\n+import { TRANSACTION_MANAGER_SERVICE } from 'src/common/constants/inject-key';\r\n+import type { ITransactionManager } from 'src/common/transaction/transaction.interface';\r\n+import { BookingDetail } from '../booking-details/entities/bookingDetails.entity';\r\n+import { PaginateDto } from 'src/common/dto/paginate.dto';\r\n+import { paginateUtil } from 'src/common/utils/paginate.util';\r\n+import { BookingPaginateDto } from './dto/booking-paginate.dto';\r\n+@Injectable()\r\n+export class BookingService {\r\n+  constructor(\r\n+    @InjectDataSource() private readonly dataSource: DataSource,\r\n+    @Inject(TRANSACTION_MANAGER_SERVICE)\r\n+    private readonly transactionManagerService: ITransactionManager,\r\n+    @InjectRepository(Booking)\r\n+    private readonly bookingRepository: Repository<Booking>,\r\n+    @InjectRepository(Concert)\r\n+    private readonly concertRepository: Repository<Concert>,\r\n+    @InjectRepository(BookingDetail)\r\n+    private readonly bookingDetailRepository: Repository<BookingDetail>,\r\n+  ) {}\r\n+\r\n+  async create(createBookingDto: CreateBookingDto, userId: string) {\r\n+    try {\r\n+      // 1. Check if the concert exists\r\n+      const concert = await this.concertRepository.findOne({\r\n+        where: { id: createBookingDto.concert },\r\n+      });\r\n+\r\n+      if (!concert) {\r\n+        throw new NotFoundException(\r\n+          `Concert with id ${createBookingDto.concert} does not exist`,\r\n+        );\r\n+      }\r\n+\r\n+      // 2. Sum up all ticket_quantity already booked for this concert\r\n+      const { sum } = await this.bookingRepository\r\n+        .createQueryBuilder('booking')\r\n+        .select('SUM(booking.ticket_quantity)', 'sum')\r\n+        .where('booking.concert = :concert', {\r\n+          concert: createBookingDto.concert,\r\n+        })\r\n+        .getRawOne();\r\n+\r\n+      const currentBooked = Number(sum) || 0;\r\n+\r\n+      // 3. Check if adding this booking would exceed the limit\r\n+      const totalAfterBooking =\r\n+        currentBooked + createBookingDto.ticket_quantity;\r\n+\r\n+        if(createBookingDto.ticket_quantity > concert.limit){\r\n+          throw new NotFoundException(\r\n+            `Concert with id ${createBookingDto.concert} has only ${concert.limit} tickets available`,\r\n+          );\r\n+        }\r\n+      if (totalAfterBooking > concert.limit) {\r\n+        throw new NotFoundException(\r\n+          `Concert with id ${createBookingDto.concert} is fully booked (${concert.limit} tickets available)`,\r\n+        );\r\n+      }\r\n+\r\n+      // Use transaction to ensure both booking and payment are created successfully\r\n+      const result = await this.transactionManagerService.runInTransaction(\r\n+        this.dataSource,\r\n+        async (manager) => {\r\n+\r\n+          // Create payment\r\n+          const payment = manager.create(Payment, {\r\n+            amount: createBookingDto.ticket_quantity ,\r\n+          });\r\n+          const savedPayment = await manager.save(Payment, payment);\r\n+\r\n+          // Calculate total amount\r\n+          const totalAmount = concert.price * createBookingDto.ticket_quantity;\r\n+\r\n+          // Create booking with proper types\r\n+          const booking = manager.create(Booking, {\r\n+            ticket_quantity: Number(createBookingDto.ticket_quantity),\r\n+            unit_price: Number(concert.price),\r\n+            total_amount: Number(totalAmount),\r\n+            user: { id: Number(userId) },\r\n+            concert: { id: Number(createBookingDto.concert) },\r\n+            payment: savedPayment,\r\n+          });\r\n+\r\n+          const savedBooking = await manager.save(Booking, booking);\r\n+\r\n+          // After saving booking...\r\n+          const details: BookingDetail[] = [];\r\n+          for (let i = 0; i < booking.ticket_quantity; i++) {\r\n+            // Generate unique ticket code           \r\n+            const detail = manager.create(BookingDetail, {\r\n+              booking: savedBooking,            \r\n+              \r\n+            });\r\n+            details.push(detail);\r\n+          }\r\n+          const savedDetails = await manager.save(BookingDetail, details);\r\n+          return {\r\n+            booking: savedBooking,\r\n+            details: savedDetails,\r\n+          };\r\n+        },\r\n+      );\r\n+\r\n+      return result;\r\n+    } catch (error) {\r\n+      console.error('Error creating booking:', error);\r\n+      throw error;\r\n+    }\r\n+  }\r\n+\r\n+  async findAll(query: BookingPaginateDto) {\r\n+    const { status } = query;\r\n+    \r\n+    const queryBuilder = this.bookingRepository\r\n+      .createQueryBuilder('booking')\r\n+      .leftJoinAndSelect('booking.user', 'user')\r\n+      .leftJoinAndSelect('user.companies', 'companies')\r\n+      .leftJoinAndSelect('booking.concert', 'concert')\r\n+      .leftJoinAndSelect('booking.payment', 'payment')\r\n+      .leftJoinAndSelect('booking.details', 'details');\r\n+\r\n+    // Add payment status filter if provided\r\n+    if (status) {\r\n+      queryBuilder.andWhere('payment.status = :status', { status });\r\n+    }\r\n+\r\n+    // Add ordering\r\n+    queryBuilder.orderBy('booking.booking_date', 'DESC');\r\n+\r\n+    // Use paginateUtil for pagination\r\n+    return paginateUtil(queryBuilder, query);\r\n+  }\r\n+\r\n+  async findOne(id: number) {\r\n+    const booking = await this.bookingRepository.findOne({\r\n+      where: { id },\r\n+      relations: ['user', 'concert', 'payment', 'details','user.companies'],\r\n+      \r\n+    });\r\n+\r\n+    if (!booking) {\r\n+      throw new NotFoundException(`Booking with ID ${id} not found`);\r\n+    }\r\n+\r\n+    return booking;\r\n+  }\r\n+\r\n+  async update(id: number, updateBookingDto: UpdateBookingDto) {\r\n+    try {\r\n+      // Get the booking with all necessary relations\r\n+      const booking = await this.bookingRepository.findOne({\r\n+        where: { id },\r\n+        relations: ['concert', 'payment'],\r\n+      });\r\n+\r\n+      if (!booking) {\r\n+        throw new NotFoundException(`Booking with ID ${id} not found`);\r\n+      }\r\n+\r\n+      // Get the concert (either current or new one)\r\n+      const concertId = updateBookingDto.concert || booking.concert.id;\r\n+      const concert = await this.concertRepository.findOne({\r\n+        where: { id: concertId },\r\n+      });\r\n+\r\n+      if (!concert) {\r\n+        throw new NotFoundException(`Concert not found`);\r\n+      }\r\n+\r\n+      // If updating ticket quantity, check concert capacity\r\n+      if (updateBookingDto.ticket_quantity) {\r\n+        // Sum up all ticket_quantity already booked for this concert excluding current booking\r\n+        const { sum } = await this.bookingRepository\r\n+          .createQueryBuilder('booking')\r\n+          .select('SUM(booking.ticket_quantity)', 'sum')\r\n+          .where('booking.concert = :concert AND booking.id != :bookingId', {\r\n+            concert: concertId,\r\n+            bookingId: id,\r\n+          })\r\n+          .getRawOne();\r\n+\r\n+        const currentBooked = Number(sum) || 0;\r\n+        const totalAfterUpdate = currentBooked + updateBookingDto.ticket_quantity;\r\n+\r\n+        if(updateBookingDto.ticket_quantity > concert.limit){\r\n+       throw new NotFoundException(\r\n+         `Concert with id ${updateBookingDto.concert} has only ${concert.limit} tickets available!`,\r\n+       );\r\n+     }\r\n+\r\n+        if (totalAfterUpdate > concert.limit) {\r\n+          throw new NotFoundException(\r\n+            `Cannot update booking: the concert is fully booked (${concert.limit} tickets available!)`,\r\n+          );\r\n+        }\r\n+      }\r\n+\r\n+      // Calculate new amounts\r\n+      const newTicketQuantity = updateBookingDto.ticket_quantity || booking.ticket_quantity;\r\n+      const totalAmount = concert.price * newTicketQuantity;\r\n+\r\n+      // Update using transaction to ensure consistency\r\n+      await this.transactionManagerService.runInTransaction(\r\n+        this.dataSource,\r\n+        async (manager) => {\r\n+          // Update booking\r\n+          await manager.update(Booking, id, {\r\n+            ticket_quantity: newTicketQuantity,\r\n+            total_amount: totalAmount,\r\n+            ...(updateBookingDto.concert ? { concert: { id: concertId } } : {})\r\n+          });\r\n+\r\n+          // Update payment amount if ticket quantity changed and payment exists\r\n+          if (updateBookingDto.ticket_quantity && booking.payment) {\r\n+            await manager\r\n+              .createQueryBuilder()\r\n+              .update(Payment)\r\n+              .set({ amount: newTicketQuantity })\r\n+              .where(\"id = :id\", { id: booking.payment.id })\r\n+              .execute();\r\n+          }\r\n+        }\r\n+      );\r\n+\r\n+      // Return updated booking\r\n+      return this.findOne(id);\r\n+    } catch (error) {\r\n+      console.error('Error in update:', error);\r\n+      throw error;\r\n+    }\r\n+  }\r\n+  \r\n+\r\n+  async delete(id: number) {\r\n+    // Start a transaction to ensure all related data is deleted properly\r\n+    return this.transactionManagerService.runInTransaction(\r\n+      this.dataSource,\r\n+      async (manager) => {\r\n+        // Find the booking with all its relations\r\n+        const booking = await manager.findOne(Booking, {\r\n+          where: { id },\r\n+          relations: ['details', 'payment'],\r\n+        });\r\n+\r\n+        if (!booking) {\r\n+          throw new NotFoundException(`Booking with ID ${id} not found`);\r\n+        }\r\n+\r\n+        // First delete all booking details\r\n+        if (booking.details && booking.details.length > 0) {\r\n+          await manager.remove(booking.details);\r\n+        }\r\n+\r\n+        // Store payment reference\r\n+        const payment = booking.payment;\r\n+\r\n+        // Remove the payment reference using QueryBuilder\r\n+        await manager\r\n+          .createQueryBuilder()\r\n+          .update(Booking)\r\n+          .set({ payment: null })\r\n+          .where(\"id = :id\", { id: booking.id })\r\n+          .execute();\r\n+\r\n+        // Now delete the booking\r\n+        await manager.remove(booking);\r\n+\r\n+        // Finally delete the payment if it exists\r\n+        if (payment) {\r\n+          await manager.remove(payment);\r\n+        }\r\n+\r\n+        return { message: `Booking with ID ${id} and all related data has been deleted` };\r\n+      }\r\n+    );\r\n+  }\r\n+\r\n+}\r\n"
                },
                {
                    "date": 1756740760136,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n         currentBooked + createBookingDto.ticket_quantity;\r\n \r\n         if(createBookingDto.ticket_quantity > concert.limit){\r\n           throw new NotFoundException(\r\n-            `Concert with id ${createBookingDto.concert} has only ${concert.limit} tickets available`,\r\n+            `Concert with id  has only ${concert.limit} tickets available`,\r\n           );\r\n         }\r\n       if (totalAfterBooking > concert.limit) {\r\n         throw new NotFoundException(\r\n@@ -283,290 +283,4 @@\n     );\r\n   }\r\n \r\n }\r\n-import { Inject, Injectable, NotFoundException } from '@nestjs/common';\r\n-import { CreateBookingDto } from './dto/create-booking.dto';\r\n-import { UpdateBookingDto } from './dto/update-booking.dto';\r\n-import { Booking } from './entities/booking.entity';\r\n-import { Payment } from '../payment/entities/payment.entity';\r\n-import { Concert } from '../concerts/entities/concert.entity';\r\n-import { Repository, DataSource } from 'typeorm';\r\n-import { InjectDataSource, InjectRepository } from '@nestjs/typeorm';\r\n-import { TRANSACTION_MANAGER_SERVICE } from 'src/common/constants/inject-key';\r\n-import type { ITransactionManager } from 'src/common/transaction/transaction.interface';\r\n-import { BookingDetail } from '../booking-details/entities/bookingDetails.entity';\r\n-import { PaginateDto } from 'src/common/dto/paginate.dto';\r\n-import { paginateUtil } from 'src/common/utils/paginate.util';\r\n-import { BookingPaginateDto } from './dto/booking-paginate.dto';\r\n-@Injectable()\r\n-export class BookingService {\r\n-  constructor(\r\n-    @InjectDataSource() private readonly dataSource: DataSource,\r\n-    @Inject(TRANSACTION_MANAGER_SERVICE)\r\n-    private readonly transactionManagerService: ITransactionManager,\r\n-    @InjectRepository(Booking)\r\n-    private readonly bookingRepository: Repository<Booking>,\r\n-    @InjectRepository(Concert)\r\n-    private readonly concertRepository: Repository<Concert>,\r\n-    @InjectRepository(BookingDetail)\r\n-    private readonly bookingDetailRepository: Repository<BookingDetail>,\r\n-  ) {}\r\n-\r\n-  async create(createBookingDto: CreateBookingDto, userId: string) {\r\n-    try {\r\n-      // 1. Check if the concert exists\r\n-      const concert = await this.concertRepository.findOne({\r\n-        where: { id: createBookingDto.concert },\r\n-      });\r\n-\r\n-      if (!concert) {\r\n-        throw new NotFoundException(\r\n-          `Concert with id ${createBookingDto.concert} does not exist`,\r\n-        );\r\n-      }\r\n-\r\n-      // 2. Sum up all ticket_quantity already booked for this concert\r\n-      const { sum } = await this.bookingRepository\r\n-        .createQueryBuilder('booking')\r\n-        .select('SUM(booking.ticket_quantity)', 'sum')\r\n-        .where('booking.concert = :concert', {\r\n-          concert: createBookingDto.concert,\r\n-        })\r\n-        .getRawOne();\r\n-\r\n-      const currentBooked = Number(sum) || 0;\r\n-\r\n-      // 3. Check if adding this booking would exceed the limit\r\n-      const totalAfterBooking =\r\n-        currentBooked + createBookingDto.ticket_quantity;\r\n-\r\n-        if(createBookingDto.ticket_quantity > concert.limit){\r\n-          throw new NotFoundException(\r\n-            `Concert with id ${createBookingDto.concert.} has only ${concert.limit} tickets available`,\r\n-          );\r\n-        }\r\n-      if (totalAfterBooking > concert.limit) {\r\n-        throw new NotFoundException(\r\n-          `Concert with id ${createBookingDto.concert} is fully booked (${concert.limit} tickets available)`,\r\n-        );\r\n-      }\r\n-\r\n-      // Use transaction to ensure both booking and payment are created successfully\r\n-      const result = await this.transactionManagerService.runInTransaction(\r\n-        this.dataSource,\r\n-        async (manager) => {\r\n-\r\n-          // Create payment\r\n-          const payment = manager.create(Payment, {\r\n-            amount: createBookingDto.ticket_quantity ,\r\n-          });\r\n-          const savedPayment = await manager.save(Payment, payment);\r\n-\r\n-          // Calculate total amount\r\n-          const totalAmount = concert.price * createBookingDto.ticket_quantity;\r\n-\r\n-          // Create booking with proper types\r\n-          const booking = manager.create(Booking, {\r\n-            ticket_quantity: Number(createBookingDto.ticket_quantity),\r\n-            unit_price: Number(concert.price),\r\n-            total_amount: Number(totalAmount),\r\n-            user: { id: Number(userId) },\r\n-            concert: { id: Number(createBookingDto.concert) },\r\n-            payment: savedPayment,\r\n-          });\r\n-\r\n-          const savedBooking = await manager.save(Booking, booking);\r\n-\r\n-          // After saving booking...\r\n-          const details: BookingDetail[] = [];\r\n-          for (let i = 0; i < booking.ticket_quantity; i++) {\r\n-            // Generate unique ticket code           \r\n-            const detail = manager.create(BookingDetail, {\r\n-              booking: savedBooking,            \r\n-              \r\n-            });\r\n-            details.push(detail);\r\n-          }\r\n-          const savedDetails = await manager.save(BookingDetail, details);\r\n-          return {\r\n-            booking: savedBooking,\r\n-            details: savedDetails,\r\n-          };\r\n-        },\r\n-      );\r\n-\r\n-      return result;\r\n-    } catch (error) {\r\n-      console.error('Error creating booking:', error);\r\n-      throw error;\r\n-    }\r\n-  }\r\n-\r\n-  async findAll(query: BookingPaginateDto) {\r\n-    const { status } = query;\r\n-    \r\n-    const queryBuilder = this.bookingRepository\r\n-      .createQueryBuilder('booking')\r\n-      .leftJoinAndSelect('booking.user', 'user')\r\n-      .leftJoinAndSelect('user.companies', 'companies')\r\n-      .leftJoinAndSelect('booking.concert', 'concert')\r\n-      .leftJoinAndSelect('booking.payment', 'payment')\r\n-      .leftJoinAndSelect('booking.details', 'details');\r\n-\r\n-    // Add payment status filter if provided\r\n-    if (status) {\r\n-      queryBuilder.andWhere('payment.status = :status', { status });\r\n-    }\r\n-\r\n-    // Add ordering\r\n-    queryBuilder.orderBy('booking.booking_date', 'DESC');\r\n-\r\n-    // Use paginateUtil for pagination\r\n-    return paginateUtil(queryBuilder, query);\r\n-  }\r\n-\r\n-  async findOne(id: number) {\r\n-    const booking = await this.bookingRepository.findOne({\r\n-      where: { id },\r\n-      relations: ['user', 'concert', 'payment', 'details','user.companies'],\r\n-      \r\n-    });\r\n-\r\n-    if (!booking) {\r\n-      throw new NotFoundException(`Booking with ID ${id} not found`);\r\n-    }\r\n-\r\n-    return booking;\r\n-  }\r\n-\r\n-  async update(id: number, updateBookingDto: UpdateBookingDto) {\r\n-    try {\r\n-      // Get the booking with all necessary relations\r\n-      const booking = await this.bookingRepository.findOne({\r\n-        where: { id },\r\n-        relations: ['concert', 'payment'],\r\n-      });\r\n-\r\n-      if (!booking) {\r\n-        throw new NotFoundException(`Booking with ID ${id} not found`);\r\n-      }\r\n-\r\n-      // Get the concert (either current or new one)\r\n-      const concertId = updateBookingDto.concert || booking.concert.id;\r\n-      const concert = await this.concertRepository.findOne({\r\n-        where: { id: concertId },\r\n-      });\r\n-\r\n-      if (!concert) {\r\n-        throw new NotFoundException(`Concert not found`);\r\n-      }\r\n-\r\n-      // If updating ticket quantity, check concert capacity\r\n-      if (updateBookingDto.ticket_quantity) {\r\n-        // Sum up all ticket_quantity already booked for this concert excluding current booking\r\n-        const { sum } = await this.bookingRepository\r\n-          .createQueryBuilder('booking')\r\n-          .select('SUM(booking.ticket_quantity)', 'sum')\r\n-          .where('booking.concert = :concert AND booking.id != :bookingId', {\r\n-            concert: concertId,\r\n-            bookingId: id,\r\n-          })\r\n-          .getRawOne();\r\n-\r\n-        const currentBooked = Number(sum) || 0;\r\n-        const totalAfterUpdate = currentBooked + updateBookingDto.ticket_quantity;\r\n-\r\n-        if(updateBookingDto.ticket_quantity > concert.limit){\r\n-       throw new NotFoundException(\r\n-         `Concert with id ${updateBookingDto.concert} has only ${concert.limit} tickets available!`,\r\n-       );\r\n-     }\r\n-\r\n-        if (totalAfterUpdate > concert.limit) {\r\n-          throw new NotFoundException(\r\n-            `Cannot update booking: the concert is fully booked (${concert.limit} tickets available!)`,\r\n-          );\r\n-        }\r\n-      }\r\n-\r\n-      // Calculate new amounts\r\n-      const newTicketQuantity = updateBookingDto.ticket_quantity || booking.ticket_quantity;\r\n-      const totalAmount = concert.price * newTicketQuantity;\r\n-\r\n-      // Update using transaction to ensure consistency\r\n-      await this.transactionManagerService.runInTransaction(\r\n-        this.dataSource,\r\n-        async (manager) => {\r\n-          // Update booking\r\n-          await manager.update(Booking, id, {\r\n-            ticket_quantity: newTicketQuantity,\r\n-            total_amount: totalAmount,\r\n-            ...(updateBookingDto.concert ? { concert: { id: concertId } } : {})\r\n-          });\r\n-\r\n-          // Update payment amount if ticket quantity changed and payment exists\r\n-          if (updateBookingDto.ticket_quantity && booking.payment) {\r\n-            await manager\r\n-              .createQueryBuilder()\r\n-              .update(Payment)\r\n-              .set({ amount: newTicketQuantity })\r\n-              .where(\"id = :id\", { id: booking.payment.id })\r\n-              .execute();\r\n-          }\r\n-        }\r\n-      );\r\n-\r\n-      // Return updated booking\r\n-      return this.findOne(id);\r\n-    } catch (error) {\r\n-      console.error('Error in update:', error);\r\n-      throw error;\r\n-    }\r\n-  }\r\n-  \r\n-\r\n-  async delete(id: number) {\r\n-    // Start a transaction to ensure all related data is deleted properly\r\n-    return this.transactionManagerService.runInTransaction(\r\n-      this.dataSource,\r\n-      async (manager) => {\r\n-        // Find the booking with all its relations\r\n-        const booking = await manager.findOne(Booking, {\r\n-          where: { id },\r\n-          relations: ['details', 'payment'],\r\n-        });\r\n-\r\n-        if (!booking) {\r\n-          throw new NotFoundException(`Booking with ID ${id} not found`);\r\n-        }\r\n-\r\n-        // First delete all booking details\r\n-        if (booking.details && booking.details.length > 0) {\r\n-          await manager.remove(booking.details);\r\n-        }\r\n-\r\n-        // Store payment reference\r\n-        const payment = booking.payment;\r\n-\r\n-        // Remove the payment reference using QueryBuilder\r\n-        await manager\r\n-          .createQueryBuilder()\r\n-          .update(Booking)\r\n-          .set({ payment: null })\r\n-          .where(\"id = :id\", { id: booking.id })\r\n-          .execute();\r\n-\r\n-        // Now delete the booking\r\n-        await manager.remove(booking);\r\n-\r\n-        // Finally delete the payment if it exists\r\n-        if (payment) {\r\n-          await manager.remove(payment);\r\n-        }\r\n-\r\n-        return { message: `Booking with ID ${id} and all related data has been deleted` };\r\n-      }\r\n-    );\r\n-  }\r\n-\r\n-}\r\n"
                },
                {
                    "date": 1756740768032,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n         currentBooked + createBookingDto.ticket_quantity;\r\n \r\n         if(createBookingDto.ticket_quantity > concert.limit){\r\n           throw new NotFoundException(\r\n-            `Concert with id  has only ${concert.limit} tickets available`,\r\n+            `tHIS Concert has only ${concert.limit} tickets available`,\r\n           );\r\n         }\r\n       if (totalAfterBooking > concert.limit) {\r\n         throw new NotFoundException(\r\n"
                },
                {
                    "date": 1756740775449,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,14 +55,14 @@\n         currentBooked + createBookingDto.ticket_quantity;\r\n \r\n         if(createBookingDto.ticket_quantity > concert.limit){\r\n           throw new NotFoundException(\r\n-            `tHIS Concert has only ${concert.limit} tickets available`,\r\n+            `This Concert has only ${concert.limit} tickets available`,\r\n           );\r\n         }\r\n       if (totalAfterBooking > concert.limit) {\r\n         throw new NotFoundException(\r\n-          `Concert with id ${createBookingDto.concert} is fully booked (${concert.limit} tickets available)`,\r\n+          `This Concert is fully booked (${concert.limit} tickets available)`,\r\n         );\r\n       }\r\n \r\n       // Use transaction to ensure both booking and payment are created successfully\r\n"
                },
                {
                    "date": 1756817545315,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -153,91 +153,111 @@\n     return booking;\r\n   }\r\n \r\n   async update(id: number, updateBookingDto: UpdateBookingDto) {\r\n-    try {\r\n-      // Get the booking with all necessary relations\r\n-      const booking = await this.bookingRepository.findOne({\r\n-        where: { id },\r\n-        relations: ['concert', 'payment'],\r\n-      });\r\n+  try {\r\n+    // 1. Fetch booking with relations\r\n+    const booking = await this.bookingRepository.findOne({\r\n+      where: { id },\r\n+      relations: ['concert', 'payment', 'details'],\r\n+    });\r\n \r\n-      if (!booking) {\r\n-        throw new NotFoundException(`Booking with ID ${id} not found`);\r\n-      }\r\n+    if (!booking) {\r\n+      throw new NotFoundException(`Booking with ID ${id} not found`);\r\n+    }\r\n \r\n-      // Get the concert (either current or new one)\r\n-      const concertId = updateBookingDto.concert || booking.concert.id;\r\n-      const concert = await this.concertRepository.findOne({\r\n-        where: { id: concertId },\r\n-      });\r\n+    // 2. Determine concert (current or updated)\r\n+    const concertId = updateBookingDto.concert || booking.concert.id;\r\n+    const concert = await this.concertRepository.findOne({\r\n+      where: { id: concertId },\r\n+    });\r\n \r\n-      if (!concert) {\r\n-        throw new NotFoundException(`Concert not found`);\r\n+    if (!concert) {\r\n+      throw new NotFoundException(`Concert with ID ${concertId} not found`);\r\n+    }\r\n+\r\n+    // 3. Validate ticket quantity\r\n+    const newTicketQuantity = updateBookingDto.ticket_quantity || booking.ticket_quantity;\r\n+\r\n+    if (updateBookingDto.ticket_quantity) {\r\n+      const { sum } = await this.bookingRepository\r\n+        .createQueryBuilder('booking')\r\n+        .select('SUM(booking.ticket_quantity)', 'sum')\r\n+        .where('booking.concert = :concert AND booking.id != :bookingId', {\r\n+          concert: concertId,\r\n+          bookingId: id,\r\n+        })\r\n+        .getRawOne();\r\n+\r\n+      const currentBooked = Number(sum) || 0;\r\n+      const totalAfterUpdate = currentBooked + newTicketQuantity;\r\n+\r\n+      if (newTicketQuantity > concert.limit) {\r\n+        throw new NotFoundException(\r\n+          `Concert with ID ${concertId} has only ${concert.limit} tickets available!`\r\n+        );\r\n       }\r\n \r\n-      // If updating ticket quantity, check concert capacity\r\n-      if (updateBookingDto.ticket_quantity) {\r\n-        // Sum up all ticket_quantity already booked for this concert excluding current booking\r\n-        const { sum } = await this.bookingRepository\r\n-          .createQueryBuilder('booking')\r\n-          .select('SUM(booking.ticket_quantity)', 'sum')\r\n-          .where('booking.concert = :concert AND booking.id != :bookingId', {\r\n-            concert: concertId,\r\n-            bookingId: id,\r\n-          })\r\n-          .getRawOne();\r\n+      if (totalAfterUpdate > concert.limit) {\r\n+        throw new NotFoundException(\r\n+          `Cannot update booking: the concert is fully booked (${concert.limit} tickets available)`\r\n+        );\r\n+      }\r\n+    }\r\n \r\n-        const currentBooked = Number(sum) || 0;\r\n-        const totalAfterUpdate = currentBooked + updateBookingDto.ticket_quantity;\r\n+    // 4. Calculate new total amount\r\n+    const totalAmount = concert.price * newTicketQuantity;\r\n \r\n-        if(updateBookingDto.ticket_quantity > concert.limit){\r\n-       throw new NotFoundException(\r\n-         `Concert with id ${updateBookingDto.concert} has only ${concert.limit} tickets available!`,\r\n-       );\r\n-     }\r\n+    // 5. Transaction: update booking, payment, and booking details\r\n+    await this.transactionManagerService.runInTransaction(this.dataSource, async (manager) => {\r\n+      // Update booking\r\n+      await manager.update(Booking, id, {\r\n+        ticket_quantity: newTicketQuantity,\r\n+        total_amount: totalAmount,\r\n+        ...(updateBookingDto.concert ? { concert: { id: concertId } } : {}),\r\n+      });\r\n \r\n-        if (totalAfterUpdate > concert.limit) {\r\n-          throw new NotFoundException(\r\n-            `Cannot update booking: the concert is fully booked (${concert.limit} tickets available!)`,\r\n-          );\r\n-        }\r\n+      // Update payment if ticket quantity changed\r\n+      if (updateBookingDto.ticket_quantity && booking.payment) {\r\n+        await manager\r\n+          .createQueryBuilder()\r\n+          .update(Payment)\r\n+          .set({ amount: newTicketQuantity })\r\n+          .where('id = :id', { id: booking.payment.id })\r\n+          .execute();\r\n       }\r\n \r\n-      // Calculate new amounts\r\n-      const newTicketQuantity = updateBookingDto.ticket_quantity || booking.ticket_quantity;\r\n-      const totalAmount = concert.price * newTicketQuantity;\r\n+      // 5a. Fetch current booking details\r\n+      const currentDetails = await manager.find(BookingDetail, { where: { booking: { id } } });\r\n \r\n-      // Update using transaction to ensure consistency\r\n-      await this.transactionManagerService.runInTransaction(\r\n-        this.dataSource,\r\n-        async (manager) => {\r\n-          // Update booking\r\n-          await manager.update(Booking, id, {\r\n-            ticket_quantity: newTicketQuantity,\r\n-            total_amount: totalAmount,\r\n-            ...(updateBookingDto.concert ? { concert: { id: concertId } } : {})\r\n-          });\r\n-\r\n-          // Update payment amount if ticket quantity changed and payment exists\r\n-          if (updateBookingDto.ticket_quantity && booking.payment) {\r\n-            await manager\r\n-              .createQueryBuilder()\r\n-              .update(Payment)\r\n-              .set({ amount: newTicketQuantity })\r\n-              .where(\"id = :id\", { id: booking.payment.id })\r\n-              .execute();\r\n-          }\r\n+      // 5b. Add or remove details to match new ticket quantity\r\n+      if (newTicketQuantity > currentDetails.length) {\r\n+        // Add missing details\r\n+        const newDetails = [];\r\n+        for (let i = currentDetails.length; i < newTicketQuantity; i++) {\r\n+          const detail = manager.create(BookingDetail, { booking: { id } });\r\n+          newDetails.push(detail);\r\n         }\r\n-      );\r\n+        await manager.save(BookingDetail, newDetails);\r\n+      } else if (newTicketQuantity < currentDetails.length) {\r\n+        // Remove extra details\r\n+        const toRemove = currentDetails.slice(newTicketQuantity);\r\n+        await manager.remove(BookingDetail, toRemove);\r\n+      }\r\n+    });\r\n \r\n-      // Return updated booking\r\n-      return this.findOne(id);\r\n-    } catch (error) {\r\n-      console.error('Error in update:', error);\r\n-      throw error;\r\n-    }\r\n+    // 6. Return updated booking with refreshed relations\r\n+    return this.bookingRepository.findOne({\r\n+      where: { id },\r\n+      relations: ['concert', 'payment', 'details'],\r\n+    });\r\n+\r\n+  } catch (error) {\r\n+    console.error('Error updating booking:', error);\r\n+    throw error;\r\n   }\r\n+}\r\n+\r\n   \r\n \r\n   async delete(id: number) {\r\n     // Start a transaction to ensure all related data is deleted properly\r\n"
                },
                {
                    "date": 1756817598952,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -236,9 +236,9 @@\n         for (let i = currentDetails.length; i < newTicketQuantity; i++) {\r\n           const detail = manager.create(BookingDetail, { booking: { id } });\r\n           newDetails.push(detail);\r\n         }\r\n-        await manager.save(BookingDetail, newDetails);\r\n+        await manager.save<BookingDetail>(newDetails);\r\n       } else if (newTicketQuantity < currentDetails.length) {\r\n         // Remove extra details\r\n         const toRemove = currentDetails.slice(newTicketQuantity);\r\n         await manager.remove(BookingDetail, toRemove);\r\n"
                },
                {
                    "date": 1756817636836,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -231,9 +231,9 @@\n \r\n       // 5b. Add or remove details to match new ticket quantity\r\n       if (newTicketQuantity > currentDetails.length) {\r\n         // Add missing details\r\n-        const newDetails = [];\r\n+       const newDetails: BookingDetail[] = [];\r\n         for (let i = currentDetails.length; i < newTicketQuantity; i++) {\r\n           const detail = manager.create(BookingDetail, { booking: { id } });\r\n           newDetails.push(detail);\r\n         }\r\n"
                },
                {
                    "date": 1756818008393,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,306 @@\n+import { Inject, Injectable, NotFoundException } from '@nestjs/common';\r\n+import { CreateBookingDto } from './dto/create-booking.dto';\r\n+import { UpdateBookingDto } from './dto/update-booking.dto';\r\n+import { Booking } from './entities/booking.entity';\r\n+import { Payment } from '../payment/entities/payment.entity';\r\n+import { Concert } from '../concerts/entities/concert.entity';\r\n+import { Repository, DataSource } from 'typeorm';\r\n+import { InjectDataSource, InjectRepository } from '@nestjs/typeorm';\r\n+import { TRANSACTION_MANAGER_SERVICE } from 'src/common/constants/inject-key';\r\n+import type { ITransactionManager } from 'src/common/transaction/transaction.interface';\r\n+import { BookingDetail } from '../booking-details/entities/bookingDetails.entity';\r\n+import { PaginateDto } from 'src/common/dto/paginate.dto';\r\n+import { paginateUtil } from 'src/common/utils/paginate.util';\r\n+import { BookingPaginateDto } from './dto/booking-paginate.dto';\r\n+@Injectable()\r\n+export class BookingService {\r\n+  constructor(\r\n+    @InjectDataSource() private readonly dataSource: DataSource,\r\n+    @Inject(TRANSACTION_MANAGER_SERVICE)\r\n+    private readonly transactionManagerService: ITransactionManager,\r\n+    @InjectRepository(Booking)\r\n+    private readonly bookingRepository: Repository<Booking>,\r\n+    @InjectRepository(Concert)\r\n+    private readonly concertRepository: Repository<Concert>,\r\n+    @InjectRepository(BookingDetail)\r\n+    private readonly bookingDetailRepository: Repository<BookingDetail>,\r\n+  ) {}\r\n+\r\n+  async create(createBookingDto: CreateBookingDto, userId: string) {\r\n+    try {\r\n+      // 1. Check if the concert exists\r\n+      const concert = await this.concertRepository.findOne({\r\n+        where: { id: createBookingDto.concert },\r\n+      });\r\n+\r\n+      if (!concert) {\r\n+        throw new NotFoundException(\r\n+          `Concert with id ${createBookingDto.concert} does not exist`,\r\n+        );\r\n+      }\r\n+\r\n+      // 2. Sum up all ticket_quantity already booked for this concert\r\n+      const { sum } = await this.bookingRepository\r\n+        .createQueryBuilder('booking')\r\n+        .select('SUM(booking.ticket_quantity)', 'sum')\r\n+        .where('booking.concert = :concert', {\r\n+          concert: createBookingDto.concert,\r\n+        })\r\n+        .getRawOne();\r\n+\r\n+      const currentBooked = Number(sum) || 0;\r\n+\r\n+      // 3. Check if adding this booking would exceed the limit\r\n+      const totalAfterBooking =\r\n+        currentBooked + createBookingDto.ticket_quantity;\r\n+\r\n+        if(createBookingDto.ticket_quantity > concert.limit){\r\n+          throw new NotFoundException(\r\n+            `This Concert has only ${concert.limit} tickets available`,\r\n+          );\r\n+        }\r\n+      if (totalAfterBooking > concert.limit) {\r\n+        throw new NotFoundException(\r\n+          `This Concert is fully booked (${concert.limit} tickets available)`,\r\n+        );\r\n+      }\r\n+\r\n+      // Use transaction to ensure both booking and payment are created successfully\r\n+      const result = await this.transactionManagerService.runInTransaction(\r\n+        this.dataSource,\r\n+        async (manager) => {\r\n+\r\n+          // Create payment\r\n+          const payment = manager.create(Payment, {\r\n+            amount: createBookingDto.ticket_quantity ,\r\n+          });\r\n+          const savedPayment = await manager.save(Payment, payment);\r\n+\r\n+          // Calculate total amount\r\n+          const totalAmount = concert.price * createBookingDto.ticket_quantity;\r\n+\r\n+          // Create booking with proper types\r\n+          const booking = manager.create(Booking, {\r\n+            ticket_quantity: Number(createBookingDto.ticket_quantity),\r\n+            unit_price: Number(concert.price),\r\n+            total_amount: Number(totalAmount),\r\n+            user: { id: Number(userId) },\r\n+            concert: { id: Number(createBookingDto.concert) },\r\n+            payment: savedPayment,\r\n+          });\r\n+\r\n+          const savedBooking = await manager.save(Booking, booking);\r\n+\r\n+          // After saving booking...\r\n+          const details: BookingDetail[] = [];\r\n+          for (let i = 0; i < booking.ticket_quantity; i++) {\r\n+            // Generate unique ticket code           \r\n+            const detail = manager.create(BookingDetail, {\r\n+              booking: savedBooking,            \r\n+              \r\n+            });\r\n+            details.push(detail);\r\n+          }\r\n+          const savedDetails = await manager.save(BookingDetail, details);\r\n+          return {\r\n+            booking: savedBooking,\r\n+            details: savedDetails,\r\n+          };\r\n+        },\r\n+      );\r\n+\r\n+      return result;\r\n+    } catch (error) {\r\n+      console.error('Error creating booking:', error);\r\n+      throw error;\r\n+    }\r\n+  }\r\n+\r\n+  async findAll(query: BookingPaginateDto) {\r\n+    const { status } = query;\r\n+    \r\n+    const queryBuilder = this.bookingRepository\r\n+      .createQueryBuilder('booking')\r\n+      .leftJoinAndSelect('booking.user', 'user')\r\n+      .leftJoinAndSelect('user.companies', 'companies')\r\n+      .leftJoinAndSelect('booking.concert', 'concert')\r\n+      .leftJoinAndSelect('booking.payment', 'payment')\r\n+      .leftJoinAndSelect('booking.details', 'details');\r\n+\r\n+    // Add payment status filter if provided\r\n+    if (status) {\r\n+      queryBuilder.andWhere('payment.status = :status', { status });\r\n+    }\r\n+\r\n+    // Add ordering\r\n+    queryBuilder.orderBy('booking.booking_date', 'DESC');\r\n+\r\n+    // Use paginateUtil for pagination\r\n+    return paginateUtil(queryBuilder, query);\r\n+  }\r\n+\r\n+  async findOne(id: number) {\r\n+    const booking = await this.bookingRepository.findOne({\r\n+      where: { id },\r\n+      relations: ['user', 'concert', 'payment', 'details','user.companies'],\r\n+      \r\n+    });\r\n+\r\n+    if (!booking) {\r\n+      throw new NotFoundException(`Booking with ID ${id} not found`);\r\n+    }\r\n+\r\n+    return booking;\r\n+  }\r\n+\r\n+  async update(id: number, updateBookingDto: UpdateBookingDto) {\r\n+  try {\r\n+    // 1. Fetch booking with relations\r\n+    const booking = await this.bookingRepository.findOne({\r\n+      where: { id },\r\n+      relations: ['concert', 'payment', 'details'],\r\n+    });\r\n+\r\n+    if (!booking) {\r\n+      throw new NotFoundException(`Booking with ID ${id} not found`);\r\n+    }\r\n+\r\n+    // 2. Determine concert (current or updated)\r\n+    const concertId = updateBookingDto.concert || booking.concert.id;\r\n+    const concert = await this.concertRepository.findOne({\r\n+      where: { id: concertId },\r\n+    });\r\n+\r\n+    if (!concert) {\r\n+      throw new NotFoundException(`Concert with ID ${concertId} not found`);\r\n+    }\r\n+\r\n+    // 3. Validate ticket quantity\r\n+    const newTicketQuantity = updateBookingDto.ticket_quantity || booking.ticket_quantity;\r\n+\r\n+    if (updateBookingDto.ticket_quantity) {\r\n+      const { sum } = await this.bookingRepository\r\n+        .createQueryBuilder('booking')\r\n+        .select('SUM(booking.ticket_quantity)', 'sum')\r\n+        .where('booking.concert = :concert AND booking.id != :bookingId', {\r\n+          concert: concertId,\r\n+          bookingId: id,\r\n+        })\r\n+        .getRawOne();\r\n+\r\n+      const currentBooked = Number(sum) || 0;\r\n+      const totalAfterUpdate = currentBooked + newTicketQuantity;\r\n+\r\n+      if (newTicketQuantity > concert.limit) {\r\n+        throw new NotFoundException(\r\n+          `Concert has only ${concert.limit} tickets available!`\r\n+        );\r\n+      }\r\n+\r\n+      if (totalAfterUpdate > concert.limit) {\r\n+        throw new NotFoundException(\r\n+          `Cannot update booking: the concert is fully booked (${concert.limit} tickets available)`\r\n+        );\r\n+      }\r\n+    }\r\n+\r\n+    // 4. Calculate new total amount\r\n+    const totalAmount = concert.price * newTicketQuantity;\r\n+\r\n+    // 5. Transaction: update booking, payment, and booking details\r\n+    await this.transactionManagerService.runInTransaction(this.dataSource, async (manager) => {\r\n+      // Update booking\r\n+      await manager.update(Booking, id, {\r\n+        ticket_quantity: newTicketQuantity,\r\n+        total_amount: totalAmount,\r\n+        ...(updateBookingDto.concert ? { concert: { id: concertId } } : {}),\r\n+      });\r\n+\r\n+      // Update payment if ticket quantity changed\r\n+      if (updateBookingDto.ticket_quantity && booking.payment) {\r\n+        await manager\r\n+          .createQueryBuilder()\r\n+          .update(Payment)\r\n+          .set({ amount: newTicketQuantity })\r\n+          .where('id = :id', { id: booking.payment.id })\r\n+          .execute();\r\n+      }\r\n+\r\n+      // 5a. Fetch current booking details\r\n+      const currentDetails = await manager.find(BookingDetail, { where: { booking: { id } } });\r\n+\r\n+      // 5b. Add or remove details to match new ticket quantity\r\n+      if (newTicketQuantity > currentDetails.length) {\r\n+        // Add missing details\r\n+       const newDetails: BookingDetail[] = [];\r\n+        for (let i = currentDetails.length; i < newTicketQuantity; i++) {\r\n+          const detail = manager.create(BookingDetail, { booking: { id } });\r\n+          newDetails.push(detail);\r\n+        }\r\n+        await manager.save<BookingDetail>(newDetails);\r\n+      } else if (newTicketQuantity < currentDetails.length) {\r\n+        // Remove extra details\r\n+        const toRemove = currentDetails.slice(newTicketQuantity);\r\n+        await manager.remove(BookingDetail, toRemove);\r\n+      }\r\n+    });\r\n+\r\n+    // 6. Return updated booking with refreshed relations\r\n+    return this.bookingRepository.findOne({\r\n+      where: { id },\r\n+      relations: ['concert', 'payment', 'details'],\r\n+    });\r\n+\r\n+  } catch (error) {\r\n+    console.error('Error updating booking:', error);\r\n+    throw error;\r\n+  }\r\n+}\r\n+\r\n+  \r\n+\r\n+  async delete(id: number) {\r\n+    // Start a transaction to ensure all related data is deleted properly\r\n+    return this.transactionManagerService.runInTransaction(\r\n+      this.dataSource,\r\n+      async (manager) => {\r\n+        // Find the booking with all its relations\r\n+        const booking = await manager.findOne(Booking, {\r\n+          where: { id },\r\n+          relations: ['details', 'payment'],\r\n+        });\r\n+\r\n+        if (!booking) {\r\n+          throw new NotFoundException(`Booking with ID ${id} not found`);\r\n+        }\r\n+\r\n+        // First delete all booking details\r\n+        if (booking.details && booking.details.length > 0) {\r\n+          await manager.remove(booking.details);\r\n+        }\r\n+\r\n+        // Store payment reference\r\n+        const payment = booking.payment;\r\n+\r\n+        // Remove the payment reference using QueryBuilder\r\n+        await manager\r\n+          .createQueryBuilder()\r\n+          .update(Booking)\r\n+          .set({ payment: null })\r\n+          .where(\"id = :id\", { id: booking.id })\r\n+          .execute();\r\n+\r\n+        // Now delete the booking\r\n+        await manager.remove(booking);\r\n+\r\n+        // Finally delete the payment if it exists\r\n+        if (payment) {\r\n+          await manager.remove(payment);\r\n+        }\r\n+\r\n+        return { message: `Booking with ID ${id} and all related data has been deleted` };\r\n+      }\r\n+    );\r\n+  }\r\n+\r\n+}\r\n"
                },
                {
                    "date": 1756818017665,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -192,9 +192,9 @@\n       const totalAfterUpdate = currentBooked + newTicketQuantity;\r\n \r\n       if (newTicketQuantity > concert.limit) {\r\n         throw new NotFoundException(\r\n-          `Concert has only ${concert.limit} tickets available!`\r\n+          `This Concert has only ${concert.limit} tickets available!`\r\n         );\r\n       }\r\n \r\n       if (totalAfterUpdate > concert.limit) {\r\n@@ -303,310 +303,4 @@\n     );\r\n   }\r\n \r\n }\r\n-import { Inject, Injectable, NotFoundException } from '@nestjs/common';\r\n-import { CreateBookingDto } from './dto/create-booking.dto';\r\n-import { UpdateBookingDto } from './dto/update-booking.dto';\r\n-import { Booking } from './entities/booking.entity';\r\n-import { Payment } from '../payment/entities/payment.entity';\r\n-import { Concert } from '../concerts/entities/concert.entity';\r\n-import { Repository, DataSource } from 'typeorm';\r\n-import { InjectDataSource, InjectRepository } from '@nestjs/typeorm';\r\n-import { TRANSACTION_MANAGER_SERVICE } from 'src/common/constants/inject-key';\r\n-import type { ITransactionManager } from 'src/common/transaction/transaction.interface';\r\n-import { BookingDetail } from '../booking-details/entities/bookingDetails.entity';\r\n-import { PaginateDto } from 'src/common/dto/paginate.dto';\r\n-import { paginateUtil } from 'src/common/utils/paginate.util';\r\n-import { BookingPaginateDto } from './dto/booking-paginate.dto';\r\n-@Injectable()\r\n-export class BookingService {\r\n-  constructor(\r\n-    @InjectDataSource() private readonly dataSource: DataSource,\r\n-    @Inject(TRANSACTION_MANAGER_SERVICE)\r\n-    private readonly transactionManagerService: ITransactionManager,\r\n-    @InjectRepository(Booking)\r\n-    private readonly bookingRepository: Repository<Booking>,\r\n-    @InjectRepository(Concert)\r\n-    private readonly concertRepository: Repository<Concert>,\r\n-    @InjectRepository(BookingDetail)\r\n-    private readonly bookingDetailRepository: Repository<BookingDetail>,\r\n-  ) {}\r\n-\r\n-  async create(createBookingDto: CreateBookingDto, userId: string) {\r\n-    try {\r\n-      // 1. Check if the concert exists\r\n-      const concert = await this.concertRepository.findOne({\r\n-        where: { id: createBookingDto.concert },\r\n-      });\r\n-\r\n-      if (!concert) {\r\n-        throw new NotFoundException(\r\n-          `Concert with id ${createBookingDto.concert} does not exist`,\r\n-        );\r\n-      }\r\n-\r\n-      // 2. Sum up all ticket_quantity already booked for this concert\r\n-      const { sum } = await this.bookingRepository\r\n-        .createQueryBuilder('booking')\r\n-        .select('SUM(booking.ticket_quantity)', 'sum')\r\n-        .where('booking.concert = :concert', {\r\n-          concert: createBookingDto.concert,\r\n-        })\r\n-        .getRawOne();\r\n-\r\n-      const currentBooked = Number(sum) || 0;\r\n-\r\n-      // 3. Check if adding this booking would exceed the limit\r\n-      const totalAfterBooking =\r\n-        currentBooked + createBookingDto.ticket_quantity;\r\n-\r\n-        if(createBookingDto.ticket_quantity > concert.limit){\r\n-          throw new NotFoundException(\r\n-            `This Concert has only ${concert.limit} tickets available`,\r\n-          );\r\n-        }\r\n-      if (totalAfterBooking > concert.limit) {\r\n-        throw new NotFoundException(\r\n-          `This Concert is fully booked (${concert.limit} tickets available)`,\r\n-        );\r\n-      }\r\n-\r\n-      // Use transaction to ensure both booking and payment are created successfully\r\n-      const result = await this.transactionManagerService.runInTransaction(\r\n-        this.dataSource,\r\n-        async (manager) => {\r\n-\r\n-          // Create payment\r\n-          const payment = manager.create(Payment, {\r\n-            amount: createBookingDto.ticket_quantity ,\r\n-          });\r\n-          const savedPayment = await manager.save(Payment, payment);\r\n-\r\n-          // Calculate total amount\r\n-          const totalAmount = concert.price * createBookingDto.ticket_quantity;\r\n-\r\n-          // Create booking with proper types\r\n-          const booking = manager.create(Booking, {\r\n-            ticket_quantity: Number(createBookingDto.ticket_quantity),\r\n-            unit_price: Number(concert.price),\r\n-            total_amount: Number(totalAmount),\r\n-            user: { id: Number(userId) },\r\n-            concert: { id: Number(createBookingDto.concert) },\r\n-            payment: savedPayment,\r\n-          });\r\n-\r\n-          const savedBooking = await manager.save(Booking, booking);\r\n-\r\n-          // After saving booking...\r\n-          const details: BookingDetail[] = [];\r\n-          for (let i = 0; i < booking.ticket_quantity; i++) {\r\n-            // Generate unique ticket code           \r\n-            const detail = manager.create(BookingDetail, {\r\n-              booking: savedBooking,            \r\n-              \r\n-            });\r\n-            details.push(detail);\r\n-          }\r\n-          const savedDetails = await manager.save(BookingDetail, details);\r\n-          return {\r\n-            booking: savedBooking,\r\n-            details: savedDetails,\r\n-          };\r\n-        },\r\n-      );\r\n-\r\n-      return result;\r\n-    } catch (error) {\r\n-      console.error('Error creating booking:', error);\r\n-      throw error;\r\n-    }\r\n-  }\r\n-\r\n-  async findAll(query: BookingPaginateDto) {\r\n-    const { status } = query;\r\n-    \r\n-    const queryBuilder = this.bookingRepository\r\n-      .createQueryBuilder('booking')\r\n-      .leftJoinAndSelect('booking.user', 'user')\r\n-      .leftJoinAndSelect('user.companies', 'companies')\r\n-      .leftJoinAndSelect('booking.concert', 'concert')\r\n-      .leftJoinAndSelect('booking.payment', 'payment')\r\n-      .leftJoinAndSelect('booking.details', 'details');\r\n-\r\n-    // Add payment status filter if provided\r\n-    if (status) {\r\n-      queryBuilder.andWhere('payment.status = :status', { status });\r\n-    }\r\n-\r\n-    // Add ordering\r\n-    queryBuilder.orderBy('booking.booking_date', 'DESC');\r\n-\r\n-    // Use paginateUtil for pagination\r\n-    return paginateUtil(queryBuilder, query);\r\n-  }\r\n-\r\n-  async findOne(id: number) {\r\n-    const booking = await this.bookingRepository.findOne({\r\n-      where: { id },\r\n-      relations: ['user', 'concert', 'payment', 'details','user.companies'],\r\n-      \r\n-    });\r\n-\r\n-    if (!booking) {\r\n-      throw new NotFoundException(`Booking with ID ${id} not found`);\r\n-    }\r\n-\r\n-    return booking;\r\n-  }\r\n-\r\n-  async update(id: number, updateBookingDto: UpdateBookingDto) {\r\n-  try {\r\n-    // 1. Fetch booking with relations\r\n-    const booking = await this.bookingRepository.findOne({\r\n-      where: { id },\r\n-      relations: ['concert', 'payment', 'details'],\r\n-    });\r\n-\r\n-    if (!booking) {\r\n-      throw new NotFoundException(`Booking with ID ${id} not found`);\r\n-    }\r\n-\r\n-    // 2. Determine concert (current or updated)\r\n-    const concertId = updateBookingDto.concert || booking.concert.id;\r\n-    const concert = await this.concertRepository.findOne({\r\n-      where: { id: concertId },\r\n-    });\r\n-\r\n-    if (!concert) {\r\n-      throw new NotFoundException(`Concert with ID ${concertId} not found`);\r\n-    }\r\n-\r\n-    // 3. Validate ticket quantity\r\n-    const newTicketQuantity = updateBookingDto.ticket_quantity || booking.ticket_quantity;\r\n-\r\n-    if (updateBookingDto.ticket_quantity) {\r\n-      const { sum } = await this.bookingRepository\r\n-        .createQueryBuilder('booking')\r\n-        .select('SUM(booking.ticket_quantity)', 'sum')\r\n-        .where('booking.concert = :concert AND booking.id != :bookingId', {\r\n-          concert: concertId,\r\n-          bookingId: id,\r\n-        })\r\n-        .getRawOne();\r\n-\r\n-      const currentBooked = Number(sum) || 0;\r\n-      const totalAfterUpdate = currentBooked + newTicketQuantity;\r\n-\r\n-      if (newTicketQuantity > concert.limit) {\r\n-        throw new NotFoundException(\r\n-          `Concert with ID ${concertId} has only ${concert.limit} tickets available!`\r\n-        );\r\n-      }\r\n-\r\n-      if (totalAfterUpdate > concert.limit) {\r\n-        throw new NotFoundException(\r\n-          `Cannot update booking: the concert is fully booked (${concert.limit} tickets available)`\r\n-        );\r\n-      }\r\n-    }\r\n-\r\n-    // 4. Calculate new total amount\r\n-    const totalAmount = concert.price * newTicketQuantity;\r\n-\r\n-    // 5. Transaction: update booking, payment, and booking details\r\n-    await this.transactionManagerService.runInTransaction(this.dataSource, async (manager) => {\r\n-      // Update booking\r\n-      await manager.update(Booking, id, {\r\n-        ticket_quantity: newTicketQuantity,\r\n-        total_amount: totalAmount,\r\n-        ...(updateBookingDto.concert ? { concert: { id: concertId } } : {}),\r\n-      });\r\n-\r\n-      // Update payment if ticket quantity changed\r\n-      if (updateBookingDto.ticket_quantity && booking.payment) {\r\n-        await manager\r\n-          .createQueryBuilder()\r\n-          .update(Payment)\r\n-          .set({ amount: newTicketQuantity })\r\n-          .where('id = :id', { id: booking.payment.id })\r\n-          .execute();\r\n-      }\r\n-\r\n-      // 5a. Fetch current booking details\r\n-      const currentDetails = await manager.find(BookingDetail, { where: { booking: { id } } });\r\n-\r\n-      // 5b. Add or remove details to match new ticket quantity\r\n-      if (newTicketQuantity > currentDetails.length) {\r\n-        // Add missing details\r\n-       const newDetails: BookingDetail[] = [];\r\n-        for (let i = currentDetails.length; i < newTicketQuantity; i++) {\r\n-          const detail = manager.create(BookingDetail, { booking: { id } });\r\n-          newDetails.push(detail);\r\n-        }\r\n-        await manager.save<BookingDetail>(newDetails);\r\n-      } else if (newTicketQuantity < currentDetails.length) {\r\n-        // Remove extra details\r\n-        const toRemove = currentDetails.slice(newTicketQuantity);\r\n-        await manager.remove(BookingDetail, toRemove);\r\n-      }\r\n-    });\r\n-\r\n-    // 6. Return updated booking with refreshed relations\r\n-    return this.bookingRepository.findOne({\r\n-      where: { id },\r\n-      relations: ['concert', 'payment', 'details'],\r\n-    });\r\n-\r\n-  } catch (error) {\r\n-    console.error('Error updating booking:', error);\r\n-    throw error;\r\n-  }\r\n-}\r\n-\r\n-  \r\n-\r\n-  async delete(id: number) {\r\n-    // Start a transaction to ensure all related data is deleted properly\r\n-    return this.transactionManagerService.runInTransaction(\r\n-      this.dataSource,\r\n-      async (manager) => {\r\n-        // Find the booking with all its relations\r\n-        const booking = await manager.findOne(Booking, {\r\n-          where: { id },\r\n-          relations: ['details', 'payment'],\r\n-        });\r\n-\r\n-        if (!booking) {\r\n-          throw new NotFoundException(`Booking with ID ${id} not found`);\r\n-        }\r\n-\r\n-        // First delete all booking details\r\n-        if (booking.details && booking.details.length > 0) {\r\n-          await manager.remove(booking.details);\r\n-        }\r\n-\r\n-        // Store payment reference\r\n-        const payment = booking.payment;\r\n-\r\n-        // Remove the payment reference using QueryBuilder\r\n-        await manager\r\n-          .createQueryBuilder()\r\n-          .update(Booking)\r\n-          .set({ payment: null })\r\n-          .where(\"id = :id\", { id: booking.id })\r\n-          .execute();\r\n-\r\n-        // Now delete the booking\r\n-        await manager.remove(booking);\r\n-\r\n-        // Finally delete the payment if it exists\r\n-        if (payment) {\r\n-          await manager.remove(payment);\r\n-        }\r\n-\r\n-        return { message: `Booking with ID ${id} and all related data has been deleted` };\r\n-      }\r\n-    );\r\n-  }\r\n-\r\n-}\r\n"
                },
                {
                    "date": 1756818758571,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -227,9 +227,27 @@\n       }\r\n \r\n       // 5a. Fetch current booking details\r\n       const currentDetails = await manager.find(BookingDetail, { where: { booking: { id } } });\r\n-       \r\n+       // Update payment status if provided\r\n+if (updateBookingDto.paymentStatus && booking.payment) {\r\n+  await manager\r\n+    .createQueryBuilder()\r\n+    .update(Payment)\r\n+    .set({ status: updateBookingDto.paymentStatus })\r\n+    .where('id = :id', { id: booking.payment.id })\r\n+    .execute();\r\n+}\r\n+\r\n+// Update booking details status if provided\r\n+if (updateBookingDto.detailsStatus) {\r\n+  await manager\r\n+    .createQueryBuilder()\r\n+    .update(BookingDetail)\r\n+    .set({ status: updateBookingDto.detailsStatus })\r\n+    .where('booking = :bookingId', { bookingId: id })\r\n+    .execute();\r\n+}\r\n       // 5b. Add or remove details to match new ticket quantity\r\n       if (newTicketQuantity > currentDetails.length) {\r\n         // Add missing details\r\n        const newDetails: BookingDetail[] = [];\r\n"
                },
                {
                    "date": 1757506682296,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,328 @@\n+import { Inject, Injectable, NotFoundException } from '@nestjs/common';\r\n+import { CreateBookingDto } from './dto/create-booking.dto';\r\n+import { UpdateBookingDto } from './dto/update-booking.dto';\r\n+import { Booking } from './entities/booking.entity';\r\n+import { Payment } from '../payment/entities/payment.entity';\r\n+import { Concert } from '../concerts/entities/concert.entity';\r\n+import { Repository, DataSource } from 'typeorm';\r\n+import { InjectDataSource, InjectRepository } from '@nestjs/typeorm';\r\n+import { TRANSACTION_MANAGER_SERVICE } from 'src/common/constants/inject-key';\r\n+import type { ITransactionManager } from 'src/common/transaction/transaction.interface';\r\n+import { BookingDetail } from '../booking-details/entities/bookingDetails.entity';\r\n+import { PaginateDto } from 'src/common/dto/paginate.dto';\r\n+import { paginateUtil } from 'src/common/utils/paginate.util';\r\n+import { BookingPaginateDto } from './dto/booking-paginate.dto';\r\n+@Injectable()\r\n+export class BookingService {\r\n+  constructor(\r\n+    @InjectDataSource() private readonly dataSource: DataSource,\r\n+    @Inject(TRANSACTION_MANAGER_SERVICE)\r\n+    private readonly transactionManagerService: ITransactionManager,\r\n+    @InjectRepository(Booking)\r\n+    private readonly bookingRepository: Repository<Booking>,\r\n+    @InjectRepository(Concert)\r\n+    private readonly concertRepository: Repository<Concert>,\r\n+    @InjectRepository(BookingDetail)\r\n+    private readonly bookingDetailRepository: Repository<BookingDetail>,\r\n+  ) {}\r\n+\r\n+  async create(createBookingDto: CreateBookingDto, userId: string) {\r\n+    try {\r\n+      // 1. Check if the concert exists\r\n+      const concert = await this.concertRepository.findOne({\r\n+        where: { id: createBookingDto.concert },\r\n+      });\r\n+\r\n+      if (!concert) {\r\n+        throw new NotFoundException(\r\n+          `Concert with id ${createBookingDto.concert} does not exist`,\r\n+        );\r\n+      }\r\n+\r\n+      // 2. Sum up all ticket_quantity already booked for this concert\r\n+      const { sum } = await this.bookingRepository\r\n+        .createQueryBuilder('booking')\r\n+        .select('SUM(booking.ticket_quantity)', 'sum')\r\n+        .where('booking.concert = :concert', {\r\n+          concert: createBookingDto.concert,\r\n+        })\r\n+        .getRawOne();\r\n+\r\n+      const currentBooked = Number(sum) || 0;\r\n+\r\n+      // 3. Check if adding this booking would exceed the limit\r\n+      const totalAfterBooking =\r\n+        currentBooked + createBookingDto.ticket_quantity;\r\n+\r\n+      if (createBookingDto.ticket_quantity > concert.limit) {\r\n+        throw new NotFoundException(\r\n+          `This Concert has only ${concert.limit} tickets available`,\r\n+        );\r\n+      }\r\n+      if (totalAfterBooking > concert.limit) {\r\n+        throw new NotFoundException(\r\n+          `This Concert is fully booked (${concert.limit} tickets available)`,\r\n+        );\r\n+      }\r\n+\r\n+      // Use transaction to ensure both booking and payment are created successfully\r\n+      const result = await this.transactionManagerService.runInTransaction(\r\n+        this.dataSource,\r\n+        async (manager) => {\r\n+          // Create payment\r\n+          const payment = manager.create(Payment, {\r\n+            amount: createBookingDto.ticket_quantity,\r\n+          });\r\n+          const savedPayment = await manager.save(Payment, payment);\r\n+\r\n+          // Calculate total amount\r\n+          const totalAmount = concert.price * createBookingDto.ticket_quantity;\r\n+\r\n+          // Create booking with proper types\r\n+          const booking = manager.create(Booking, {\r\n+            ticket_quantity: Number(createBookingDto.ticket_quantity),\r\n+            unit_price: Number(concert.price),\r\n+            total_amount: Number(totalAmount),\r\n+            user: { id: Number(userId) },\r\n+            concert: { id: Number(createBookingDto.concert) },\r\n+            payment: savedPayment,\r\n+          });\r\n+\r\n+          const savedBooking = await manager.save(Booking, booking);\r\n+\r\n+          // After saving booking...\r\n+          const details: BookingDetail[] = [];\r\n+          for (let i = 0; i < booking.ticket_quantity; i++) {\r\n+            // Generate unique ticket code\r\n+            const detail = manager.create(BookingDetail, {\r\n+              booking: savedBooking,\r\n+            });\r\n+            details.push(detail);\r\n+          }\r\n+          const savedDetails = await manager.save(BookingDetail, details);\r\n+          return {\r\n+            booking: savedBooking,\r\n+            details: savedDetails,\r\n+          };\r\n+        },\r\n+      );\r\n+\r\n+      return result;\r\n+    } catch (error) {\r\n+      console.error('Error creating booking:', error);\r\n+      throw error;\r\n+    }\r\n+  }\r\n+\r\n+  async findAll(query: BookingPaginateDto ,userId?: ) {\r\n+    const { status , companyId} = query;\r\n+\r\n+    const queryBuilder = this.bookingRepository\r\n+      .createQueryBuilder('booking')\r\n+      .leftJoinAndSelect('booking.user', 'user')\r\n+      .leftJoinAndSelect('user.companies', 'companies')\r\n+      .leftJoinAndSelect('booking.concert', 'concert')\r\n+      .leftJoinAndSelect('booking.payment', 'payment')\r\n+      .leftJoinAndSelect('booking.details', 'details');\r\n+\r\n+    // Add payment status filter if provided\r\n+    if (status) {\r\n+      queryBuilder.andWhere('payment.status = :status', { status });\r\n+    }\r\n+    if (companyId) {\r\n+      queryBuilder.andWhere('companies.id = :companyId', { companyId });\r\n+    }\r\n+\r\n+    // Add ordering\r\n+    queryBuilder.orderBy('booking.booking_date', 'DESC');\r\n+\r\n+    // Use paginateUtil for pagination\r\n+    return paginateUtil(queryBuilder, query);\r\n+  }\r\n+\r\n+  async findOne(id: number) {\r\n+    const booking = await this.bookingRepository.findOne({\r\n+      where: { id },\r\n+      relations: ['user', 'concert', 'payment', 'details', 'user.companies'],\r\n+    });\r\n+\r\n+    if (!booking) {\r\n+      throw new NotFoundException(`Booking with ID ${id} not found`);\r\n+    }\r\n+\r\n+    return booking;\r\n+  }\r\n+\r\n+  async update(id: number, updateBookingDto: UpdateBookingDto) {\r\n+    try {\r\n+      // 1. Fetch booking with relations\r\n+      const booking = await this.bookingRepository.findOne({\r\n+        where: { id },\r\n+        relations: ['concert', 'payment', 'details'],\r\n+      });\r\n+\r\n+      if (!booking) {\r\n+        throw new NotFoundException(`Booking with ID ${id} not found`);\r\n+      }\r\n+\r\n+      // 2. Determine concert (current or updated)\r\n+      const concertId = updateBookingDto.concert || booking.concert.id;\r\n+      const concert = await this.concertRepository.findOne({\r\n+        where: { id: concertId },\r\n+      });\r\n+\r\n+      if (!concert) {\r\n+        throw new NotFoundException(`Concert with ID ${concertId} not found`);\r\n+      }\r\n+\r\n+      // 3. Validate ticket quantity\r\n+      const newTicketQuantity =\r\n+        updateBookingDto.ticket_quantity || booking.ticket_quantity;\r\n+\r\n+      if (updateBookingDto.ticket_quantity) {\r\n+        const { sum } = await this.bookingRepository\r\n+          .createQueryBuilder('booking')\r\n+          .select('SUM(booking.ticket_quantity)', 'sum')\r\n+          .where('booking.concert = :concert AND booking.id != :bookingId', {\r\n+            concert: concertId,\r\n+            bookingId: id,\r\n+          })\r\n+          .getRawOne();\r\n+\r\n+        const currentBooked = Number(sum) || 0;\r\n+        const totalAfterUpdate = currentBooked + newTicketQuantity;\r\n+\r\n+        if (newTicketQuantity > concert.limit) {\r\n+          throw new NotFoundException(\r\n+            `This Concert has only ${concert.limit} tickets available!`,\r\n+          );\r\n+        }\r\n+\r\n+        if (totalAfterUpdate > concert.limit) {\r\n+          throw new NotFoundException(\r\n+            `Cannot update booking: the concert is fully booked (${concert.limit} tickets available)`,\r\n+          );\r\n+        }\r\n+      }\r\n+\r\n+      // 4. Calculate new total amount\r\n+      const totalAmount = concert.price * newTicketQuantity;\r\n+\r\n+      // 5. Transaction: update booking, payment, and booking details\r\n+      await this.transactionManagerService.runInTransaction(\r\n+        this.dataSource,\r\n+        async (manager) => {\r\n+          // Update booking\r\n+          await manager.update(Booking, id, {\r\n+            ticket_quantity: newTicketQuantity,\r\n+            total_amount: totalAmount,\r\n+            ...(updateBookingDto.concert ? { concert: { id: concertId } } : {}),\r\n+          });\r\n+\r\n+          // Update payment if ticket quantity changed\r\n+          if (updateBookingDto.ticket_quantity && booking.payment) {\r\n+            await manager\r\n+              .createQueryBuilder()\r\n+              .update(Payment)\r\n+              .set({ amount: newTicketQuantity })\r\n+              .where('id = :id', { id: booking.payment.id })\r\n+              .execute();\r\n+          }\r\n+\r\n+          // 5a. Fetch current booking details\r\n+          const currentDetails = await manager.find(BookingDetail, {\r\n+            where: { booking: { id } },\r\n+          });\r\n+          // Update payment status if provided\r\n+          if (updateBookingDto.paymentStatus && booking.payment) {\r\n+            await manager\r\n+              .createQueryBuilder()\r\n+              .update(Payment)\r\n+              .set({ status: updateBookingDto.paymentStatus })\r\n+              .where('id = :id', { id: booking.payment.id })\r\n+              .execute();\r\n+          }\r\n+\r\n+          // Update booking details status if provided\r\n+          if (updateBookingDto.detailsId && updateBookingDto.detailsStatus) {\r\n+            await manager\r\n+              .createQueryBuilder()\r\n+              .update(BookingDetail)\r\n+              .set({ status: updateBookingDto.detailsStatus })\r\n+              .where('id = :id', { id: updateBookingDto.detailsId })\r\n+              .execute();\r\n+          }\r\n+          // 5b. Add or remove details to match new ticket quantity\r\n+          if (newTicketQuantity > currentDetails.length) {\r\n+            // Add missing details\r\n+            const newDetails: BookingDetail[] = [];\r\n+            for (let i = currentDetails.length; i < newTicketQuantity; i++) {\r\n+              const detail = manager.create(BookingDetail, { booking: { id } });\r\n+              newDetails.push(detail);\r\n+            }\r\n+            await manager.save<BookingDetail>(newDetails);\r\n+          } else if (newTicketQuantity < currentDetails.length) {\r\n+            // Remove extra details\r\n+            const toRemove = currentDetails.slice(newTicketQuantity);\r\n+            await manager.remove(BookingDetail, toRemove);\r\n+          }\r\n+        },\r\n+      );\r\n+\r\n+      // 6. Return updated booking with refreshed relations\r\n+      return this.bookingRepository.findOne({\r\n+        where: { id },\r\n+        relations: ['concert', 'payment', 'details'],\r\n+      });\r\n+    } catch (error) {\r\n+      console.error('Error updating booking:', error);\r\n+      throw error;\r\n+    }\r\n+  }\r\n+\r\n+  async delete(id: number) {\r\n+    // Start a transaction to ensure all related data is deleted properly\r\n+    return this.transactionManagerService.runInTransaction(\r\n+      this.dataSource,\r\n+      async (manager) => {\r\n+        // Find the booking with all its relations\r\n+        const booking = await manager.findOne(Booking, {\r\n+          where: { id },\r\n+          relations: ['details', 'payment'],\r\n+        });\r\n+\r\n+        if (!booking) {\r\n+          throw new NotFoundException(`Booking with ID ${id} not found`);\r\n+        }\r\n+\r\n+        // First delete all booking details\r\n+        if (booking.details && booking.details.length > 0) {\r\n+          await manager.remove(booking.details);\r\n+        }\r\n+\r\n+        // Store payment reference\r\n+        const payment = booking.payment;\r\n+\r\n+        // Remove the payment reference using QueryBuilder\r\n+        await manager\r\n+          .createQueryBuilder()\r\n+          .update(Booking)\r\n+          .set({ payment: null })\r\n+          .where('id = :id', { id: booking.id })\r\n+          .execute();\r\n+\r\n+        // Now delete the booking\r\n+        await manager.remove(booking);\r\n+\r\n+        // Finally delete the payment if it exists\r\n+        if (payment) {\r\n+          await manager.remove(payment);\r\n+        }\r\n+\r\n+        return {\r\n+          message: `Booking with ID ${id} and all related data has been deleted`,\r\n+        };\r\n+      },\r\n+    );\r\n+  }\r\n+}\r\n"
                }
            ],
            "date": 1756740733216,
            "name": "Commit-0",
            "content": "import { Inject, Injectable, NotFoundException } from '@nestjs/common';\r\nimport { CreateBookingDto } from './dto/create-booking.dto';\r\nimport { UpdateBookingDto } from './dto/update-booking.dto';\r\nimport { Booking } from './entities/booking.entity';\r\nimport { Payment } from '../payment/entities/payment.entity';\r\nimport { Concert } from '../concerts/entities/concert.entity';\r\nimport { Repository, DataSource } from 'typeorm';\r\nimport { InjectDataSource, InjectRepository } from '@nestjs/typeorm';\r\nimport { TRANSACTION_MANAGER_SERVICE } from 'src/common/constants/inject-key';\r\nimport type { ITransactionManager } from 'src/common/transaction/transaction.interface';\r\nimport { BookingDetail } from '../booking-details/entities/bookingDetails.entity';\r\nimport { PaginateDto } from 'src/common/dto/paginate.dto';\r\nimport { paginateUtil } from 'src/common/utils/paginate.util';\r\nimport { BookingPaginateDto } from './dto/booking-paginate.dto';\r\n@Injectable()\r\nexport class BookingService {\r\n  constructor(\r\n    @InjectDataSource() private readonly dataSource: DataSource,\r\n    @Inject(TRANSACTION_MANAGER_SERVICE)\r\n    private readonly transactionManagerService: ITransactionManager,\r\n    @InjectRepository(Booking)\r\n    private readonly bookingRepository: Repository<Booking>,\r\n    @InjectRepository(Concert)\r\n    private readonly concertRepository: Repository<Concert>,\r\n    @InjectRepository(BookingDetail)\r\n    private readonly bookingDetailRepository: Repository<BookingDetail>,\r\n  ) {}\r\n\r\n  async create(createBookingDto: CreateBookingDto, userId: string) {\r\n    try {\r\n      // 1. Check if the concert exists\r\n      const concert = await this.concertRepository.findOne({\r\n        where: { id: createBookingDto.concert },\r\n      });\r\n\r\n      if (!concert) {\r\n        throw new NotFoundException(\r\n          `Concert with id ${createBookingDto.concert} does not exist`,\r\n        );\r\n      }\r\n\r\n      // 2. Sum up all ticket_quantity already booked for this concert\r\n      const { sum } = await this.bookingRepository\r\n        .createQueryBuilder('booking')\r\n        .select('SUM(booking.ticket_quantity)', 'sum')\r\n        .where('booking.concert = :concert', {\r\n          concert: createBookingDto.concert,\r\n        })\r\n        .getRawOne();\r\n\r\n      const currentBooked = Number(sum) || 0;\r\n\r\n      // 3. Check if adding this booking would exceed the limit\r\n      const totalAfterBooking =\r\n        currentBooked + createBookingDto.ticket_quantity;\r\n\r\n        if(createBookingDto.ticket_quantity > concert.limit){\r\n          throw new NotFoundException(\r\n            `Concert with id ${createBookingDto.concert.} has only ${concert.limit} tickets available`,\r\n          );\r\n        }\r\n      if (totalAfterBooking > concert.limit) {\r\n        throw new NotFoundException(\r\n          `Concert with id ${createBookingDto.concert} is fully booked (${concert.limit} tickets available)`,\r\n        );\r\n      }\r\n\r\n      // Use transaction to ensure both booking and payment are created successfully\r\n      const result = await this.transactionManagerService.runInTransaction(\r\n        this.dataSource,\r\n        async (manager) => {\r\n\r\n          // Create payment\r\n          const payment = manager.create(Payment, {\r\n            amount: createBookingDto.ticket_quantity ,\r\n          });\r\n          const savedPayment = await manager.save(Payment, payment);\r\n\r\n          // Calculate total amount\r\n          const totalAmount = concert.price * createBookingDto.ticket_quantity;\r\n\r\n          // Create booking with proper types\r\n          const booking = manager.create(Booking, {\r\n            ticket_quantity: Number(createBookingDto.ticket_quantity),\r\n            unit_price: Number(concert.price),\r\n            total_amount: Number(totalAmount),\r\n            user: { id: Number(userId) },\r\n            concert: { id: Number(createBookingDto.concert) },\r\n            payment: savedPayment,\r\n          });\r\n\r\n          const savedBooking = await manager.save(Booking, booking);\r\n\r\n          // After saving booking...\r\n          const details: BookingDetail[] = [];\r\n          for (let i = 0; i < booking.ticket_quantity; i++) {\r\n            // Generate unique ticket code           \r\n            const detail = manager.create(BookingDetail, {\r\n              booking: savedBooking,            \r\n              \r\n            });\r\n            details.push(detail);\r\n          }\r\n          const savedDetails = await manager.save(BookingDetail, details);\r\n          return {\r\n            booking: savedBooking,\r\n            details: savedDetails,\r\n          };\r\n        },\r\n      );\r\n\r\n      return result;\r\n    } catch (error) {\r\n      console.error('Error creating booking:', error);\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  async findAll(query: BookingPaginateDto) {\r\n    const { status } = query;\r\n    \r\n    const queryBuilder = this.bookingRepository\r\n      .createQueryBuilder('booking')\r\n      .leftJoinAndSelect('booking.user', 'user')\r\n      .leftJoinAndSelect('user.companies', 'companies')\r\n      .leftJoinAndSelect('booking.concert', 'concert')\r\n      .leftJoinAndSelect('booking.payment', 'payment')\r\n      .leftJoinAndSelect('booking.details', 'details');\r\n\r\n    // Add payment status filter if provided\r\n    if (status) {\r\n      queryBuilder.andWhere('payment.status = :status', { status });\r\n    }\r\n\r\n    // Add ordering\r\n    queryBuilder.orderBy('booking.booking_date', 'DESC');\r\n\r\n    // Use paginateUtil for pagination\r\n    return paginateUtil(queryBuilder, query);\r\n  }\r\n\r\n  async findOne(id: number) {\r\n    const booking = await this.bookingRepository.findOne({\r\n      where: { id },\r\n      relations: ['user', 'concert', 'payment', 'details','user.companies'],\r\n      \r\n    });\r\n\r\n    if (!booking) {\r\n      throw new NotFoundException(`Booking with ID ${id} not found`);\r\n    }\r\n\r\n    return booking;\r\n  }\r\n\r\n  async update(id: number, updateBookingDto: UpdateBookingDto) {\r\n    try {\r\n      // Get the booking with all necessary relations\r\n      const booking = await this.bookingRepository.findOne({\r\n        where: { id },\r\n        relations: ['concert', 'payment'],\r\n      });\r\n\r\n      if (!booking) {\r\n        throw new NotFoundException(`Booking with ID ${id} not found`);\r\n      }\r\n\r\n      // Get the concert (either current or new one)\r\n      const concertId = updateBookingDto.concert || booking.concert.id;\r\n      const concert = await this.concertRepository.findOne({\r\n        where: { id: concertId },\r\n      });\r\n\r\n      if (!concert) {\r\n        throw new NotFoundException(`Concert not found`);\r\n      }\r\n\r\n      // If updating ticket quantity, check concert capacity\r\n      if (updateBookingDto.ticket_quantity) {\r\n        // Sum up all ticket_quantity already booked for this concert excluding current booking\r\n        const { sum } = await this.bookingRepository\r\n          .createQueryBuilder('booking')\r\n          .select('SUM(booking.ticket_quantity)', 'sum')\r\n          .where('booking.concert = :concert AND booking.id != :bookingId', {\r\n            concert: concertId,\r\n            bookingId: id,\r\n          })\r\n          .getRawOne();\r\n\r\n        const currentBooked = Number(sum) || 0;\r\n        const totalAfterUpdate = currentBooked + updateBookingDto.ticket_quantity;\r\n\r\n        if(updateBookingDto.ticket_quantity > concert.limit){\r\n       throw new NotFoundException(\r\n         `Concert with id ${updateBookingDto.concert} has only ${concert.limit} tickets available!`,\r\n       );\r\n     }\r\n\r\n        if (totalAfterUpdate > concert.limit) {\r\n          throw new NotFoundException(\r\n            `Cannot update booking: the concert is fully booked (${concert.limit} tickets available!)`,\r\n          );\r\n        }\r\n      }\r\n\r\n      // Calculate new amounts\r\n      const newTicketQuantity = updateBookingDto.ticket_quantity || booking.ticket_quantity;\r\n      const totalAmount = concert.price * newTicketQuantity;\r\n\r\n      // Update using transaction to ensure consistency\r\n      await this.transactionManagerService.runInTransaction(\r\n        this.dataSource,\r\n        async (manager) => {\r\n          // Update booking\r\n          await manager.update(Booking, id, {\r\n            ticket_quantity: newTicketQuantity,\r\n            total_amount: totalAmount,\r\n            ...(updateBookingDto.concert ? { concert: { id: concertId } } : {})\r\n          });\r\n\r\n          // Update payment amount if ticket quantity changed and payment exists\r\n          if (updateBookingDto.ticket_quantity && booking.payment) {\r\n            await manager\r\n              .createQueryBuilder()\r\n              .update(Payment)\r\n              .set({ amount: newTicketQuantity })\r\n              .where(\"id = :id\", { id: booking.payment.id })\r\n              .execute();\r\n          }\r\n        }\r\n      );\r\n\r\n      // Return updated booking\r\n      return this.findOne(id);\r\n    } catch (error) {\r\n      console.error('Error in update:', error);\r\n      throw error;\r\n    }\r\n  }\r\n  \r\n\r\n  async delete(id: number) {\r\n    // Start a transaction to ensure all related data is deleted properly\r\n    return this.transactionManagerService.runInTransaction(\r\n      this.dataSource,\r\n      async (manager) => {\r\n        // Find the booking with all its relations\r\n        const booking = await manager.findOne(Booking, {\r\n          where: { id },\r\n          relations: ['details', 'payment'],\r\n        });\r\n\r\n        if (!booking) {\r\n          throw new NotFoundException(`Booking with ID ${id} not found`);\r\n        }\r\n\r\n        // First delete all booking details\r\n        if (booking.details && booking.details.length > 0) {\r\n          await manager.remove(booking.details);\r\n        }\r\n\r\n        // Store payment reference\r\n        const payment = booking.payment;\r\n\r\n        // Remove the payment reference using QueryBuilder\r\n        await manager\r\n          .createQueryBuilder()\r\n          .update(Booking)\r\n          .set({ payment: null })\r\n          .where(\"id = :id\", { id: booking.id })\r\n          .execute();\r\n\r\n        // Now delete the booking\r\n        await manager.remove(booking);\r\n\r\n        // Finally delete the payment if it exists\r\n        if (payment) {\r\n          await manager.remove(payment);\r\n        }\r\n\r\n        return { message: `Booking with ID ${id} and all related data has been deleted` };\r\n      }\r\n    );\r\n  }\r\n\r\n}\r\n"
        }
    ]
}